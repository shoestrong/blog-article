[{"title":"node.js建立个简单的web服务器","date":"2016-11-15T02:09:52.000Z","path":"/template/20161115/node-webserver/","text":"接触nodejs还不算太多，欠缺的知识方面很多。 就来试着搭建一下，废话少说直接上代码： cmd: 123cd ./myServer &lt;自己的文件目录&gt;node server.js &lt;直接node下运行server.js&gt; server.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// 这是一个简单的Node HTTP服务器,能处理当前目录的文件// 并能实现两种特殊的URL用于测试// 用HTTP://localhost:4000或http://127.0.0.1:4000连接这个服务器// 首先加载所有需要用到的模块var http = require('http'); // Http服务器APIvar fs = require('fs'); // 用于处理本地文件var server = new http.Server(); // 创建新的HTTP服务器server.listen(4000); // 监听端口4000// 使用on方法注册时间处理server.on('request', function(request, response) &#123; // 当有request请求的时候触发处理函数 console.log('Request'); // 解析请求的URL var url = require('url').parse(request.url); // 特殊URL会让服务器在发送响应前先等待 switch(url.pathname) &#123; case ''||'/' : // 模拟欢迎页,nodejs是高效流处理的方案,也可以通过配置文件来配置 fs.readFile('./index.html', function(err, content)&#123; if(err) &#123; response.writeHead(404, &#123; 'Content-Type':'text/plain; charset=\"UTF-8\"' &#125;); response.write(err.message); response.end(); &#125; else &#123; response.writeHead(200, &#123; 'Content-Type' : 'text/html; charset=UTF-8' &#125;); response.write(content); response.end(); &#125; &#125;); break; case '/test/delay':// 此处用于模拟缓慢的网络连接 // 使用查询字符串来获取延迟时长,或者2000毫秒 var delay = parseInt(url.query) || 2000; // 设置响应状态和头 response.writeHead(200, &#123;'Content-type':'text/plain; charset=UTF-8'&#125;); // 立即开始编写响应主体 response.write('Sleeping for' + delay + ' milliseconds...'); // 在之后调用的另一个函数中完成响应 setTimeout(function()&#123; response.write('done.'); response.end(); &#125;, delay); break; case '/test/mirror':// 如果请求是test/mirror,则原文返回它 // 响应状态和头 response.writeHead(200, &#123;'Content-type':'text/plain; charset=UTF-8'&#125;); // 用请求的内容开始编写响应主体 response.write(request.mothod + ' ' + request.url + ' HTTP/' + request.httpVersion + '\\r\\n'); // 所有的请求头 for (var h in request.headers) &#123; response.write(h + ':' + request.headers[h] + '\\r\\n'); &#125; response.write('\\r\\n');// 使用额外的空白行来结束头 // 在这些事件处理程序函数中完成响应 // 当请求主体的数据块完成时,把其写入响应中 request.on('data', function(chunk) &#123; response.write(chunk); &#125;); // 当请求结束时,响应也完成 request.on('end', function(chunk)&#123; response.end(); &#125;); break; case '/json' : // 模拟JSON数据返回 // 响应状态和头 response.writeHead(200, &#123;'Content-type':'application/json; charset=UTF-8'&#125;); response.write(JSON.stringify(&#123;test:'success'&#125;)); response.end(); break; default:// 处理来自本地目录的文件 var filename = url.pathname.substring(1); // 去掉前导'/' var type = getType(filename.substring(filename.lastIndexOf('.')+1)); // 异步读取文件,并将内容作为单独的数据模块传给回调函数 // 对于确实很大的文件,使用流API fs.createReadStream()更好 fs.readFile(filename, function(err, content)&#123; if(err) &#123; response.writeHead(404, &#123; 'Content-Type':'text/plain; charset=\"UTF-8\"' &#125;); response.write(err.message); response.end(); &#125; else &#123; response.writeHead(200, &#123; 'Content-Type' : type &#125;); response.write(content); response.end(); &#125; &#125;); break; &#125; &#125;);function getType(endTag)&#123; var type=null; switch(endTag)&#123; case 'html' : case 'htm' : type = 'text/html; charset=UTF-8'; break; case 'js' : type = 'application/javascript; charset=\"UTF-8\"'; break; case 'css' : type = 'text/css; charset=\"UTF-8\"'; break; case 'txt' : type = 'text/plain; charset=\"UTF-8\"'; break; case 'manifest' : type = 'text/cache-manifest; charset=\"UTF-8\"'; break; default : type = 'application/octet-stream'; break; &#125; return type;&#125;//向控制台输出服务启动的信息 console.log('[WebServer][Start] running at http://localhost:4000'); 在localhost:4000预览就OK了。","tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"搞定git分支","date":"2016-11-10T02:09:52.000Z","path":"/template/20161110/git-master/","text":"查看远程分支 12345678$ git branch -a * br-2.1.2.2 master remotes/origin/HEAD -&gt; origin/master remotes/origin/br-2.1.2.1 remotes/origin/br-2.1.2.2 remotes/origin/br-2.1.3 remotes/origin/master 查看本地分支 123$ git branch -a * br-2.1.2.2 master 创建分支 12345$ git branch test $ git branch * br-2.1.2.2 master test 把分支推到远程分支 1$ git push origin test 切换分支到test 1234567891011121314$ git branch * br-2.1.2.2 master test $ git checkout test M Shoestrong-server/src/main/java/com/taobao/Shoestrong/server/service/cmd/GetCustomerTarCmd.java M Shoestrong-server/src/main/java/com/taobao/Shoestrong/server/util/ServerUtil.java Switched to branch &apos;test&apos; $ git branch br-2.1.2.2 master * test M 表示cong 原来分支（上一次修改没有提交br-2.1.2.2）带过来的修改 删除本地分支 git branch -d xxxxx 12345678910111213141516$ git checkout br-2.1.2.2 M Shoestrong-server/src/main/java/com/taobao/Shoestrong/server/service/cmd/GetCustomerTarCmd.java M Shoestrong-server/src/main/java/com/taobao/Shoestrong/server/util/ServerUtil.java Switched to branch &apos;br-2.1.2.2&apos; $ git br * br-2.1.2.2 master test $ git br -d test Deleted branch test (was 17d28d9). $ git br * br-2.1.2.2 master 查看本地和远程分支 -a。前面带*号的代表你当前工作目录所处的分支 1remotes/origin/HEAD -&gt; origin/master #啥意思呢？ ”在clone完成之后，Git 会自动为你将此远程仓库命名为origin（origin只相当于一个别名，运行git remote –v或者查看.git\\/config可以看到origin的含义），并下载其中所有的数据，建立一个指向它的master 分支的指针，我们用(远程仓库名)\\/(分支名) 这样的形式表示远程分支，所以origin\\/master指向的是一个remote branch（从那个branch我们clone数据到本地）“这个是执行 git remote -v 的结果，看出来origin其实就是远程的git地址的一个别名。 123$ git remote -v origin git@xxxx/Shoestrong.git (fetch) origin git@xxxx/Shoestrong.git (push) 123456789$ git branch -a br-2.1.2.2 master * test remotes/origin/HEAD -&gt; origin/master remotes/origin/br-2.1.2.1 remotes/origin/br-2.1.2.2 remotes/origin/br-2.1.3 remotes/origin/master 删除远程版本 1git push origin :br-1.0.0 删除远程分支 12git branch -r -d origin/branch-name git push origin :branch-name","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"sublime 编辑器配置和构建检查","date":"2016-09-12T08:50:00.000Z","path":"/template/20160912/sublime-set/","text":"sublime安装配置安装node包 jscs npm install jscs -g jshint npm install jshint -g csscomb npm install csscomb -g csslint npm install csslint -g 安装gem包 scss-lint gem install scss_lint 安装sublime3 Package Control 按下 `ctrl+`` 复制粘贴以下代码 12`import urllib.request,os,hashlib; h = &apos;eb2297e1a458f27d836c04bb0cbaf282&apos; + &apos;d0e7a3098092775ccb37ca9d6b2e4b7d&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest();print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)` 安装sublime3插件 按下 ctrl+shift+p，输入’ip’（Install Package） 输入以下插件的名字，按顺序逐个进行安装： EditorConfig Sass SublimeLinter SublimeLinter-jscs SublimeLinter-jshint SublimeLinter-csslint SublimeLinter-contrib-scss-lint JSFormat CSScomb 插件的配置文件将以下配置文件分别下载后放入项目根目录下： EditorConfig配置文件 JSCS配置文件 JSHint配置文件 注意：全局变量需要手动加到配置文件的globals属性里，例： 12345&#123; &quot;globals&quot;: &#123; &quot;ImageHandle&quot;: true &#125;&#125; CSSLint配置文件 SCSS-Lint配置文件 编辑器及插件设置 sublime3 自身 Preferences-&gt;Setting-User，增加下面两个配置：1234&#123; &quot;translate_tabs_to_spaces&quot;: true, &quot;word_wrap&quot;: true&#125; 点击右下角的Spaces-&gt;Convert Indentation to Spaces可以将文件中的所有tab转换成空格 JSFormat Preferences-&gt;Package Settings-&gt;JSFormat-&gt;Setting-User，下载配置文件覆盖 配置好后格式化的默认快捷键是 ctrl+alt+f SublimeLinter 右键-&gt;SublimeLinter-&gt;Lint Mode，有4种检查模式，建议选择 Load/save 右键-&gt;SublimeLinter-&gt;Mark Style，建议选择 Outline 右键-&gt;SublimeLinter-&gt;Choose Gutter Theme，建议选择 Blueberry-round 右键-&gt;SublimeLinter-&gt;Open User Settings，将linter里面jscs的args改成 [&quot;--verbose&quot;]，将linter里面csslint的ignore改成 &quot;box-model,adjoining-classes,box-sizing,compatible-vendor-prefixes,gradients,text-indent,fallback-colors,star-property-hack,underscore-property-hack,bulletproof-font-face,font-faces,import,regex-selectors,universal-selector,unqualified-attributes,overqualified-elements,duplicate-background-images,floats,font-sizes,ids,important,outline-none,qualified-headings,unique-headings&quot; 当光标处于有错误的代码行时，详细的错误信息会显示在下面的状态栏中 右键-&gt;SublimeLinter可以看到所有的快捷键，其中 ctrl+k, a 可以列出所有错误 CSScomb Preferences-&gt;Package Settings-&gt;CSScomb-&gt;Setting-User，下载配置文件覆盖 配置好后格式化的默认快捷键是 ctrl+shift+c grunt插件在项目中安装grunt插件jscs npm install grunt-jscs --save-dev jshint npm install grunt-contrib-jshint --save-devcsslint npm install grunt-contrib-csslint --save-dev scss-lint npm install grunt-scss-lint --save-dev 插件的配置文件 JSCS 123456789&#123; options: &#123; config: true, verbose: true &#125;, files: &#123; src: [...] &#125;&#125; JSHint 12345678&#123; options: &#123; jshintrc: true &#125;, files: &#123; src: [...] &#125;&#125; CSSLint 12345678&#123; options: &#123; csslintrc: &apos;.csslintrc&apos; &#125;, files: &#123; src: [...] &#125;&#125; SCSS-Lint 12345678&#123; options: &#123; config: &apos;.scss-lint.yml&apos; &#125;, files: &#123; src: [...] &#125;&#125;","tags":[{"name":"sublime","slug":"sublime","permalink":"http://yoursite.com/tags/sublime/"},{"name":"编辑器","slug":"编辑器","permalink":"http://yoursite.com/tags/编辑器/"}]}]