[{"title":"sublime 编辑器配置和构建检查","date":"2016-09-12T08:50:00.000Z","path":"/template/20160912/sublime-set/","text":"sublime安装配置安装node包 jscs npm install jscs -g jshint npm install jshint -g csscomb npm install csscomb -g csslint npm install csslint -g 安装gem包 scss-lint gem install scss_lint 安装sublime3 Package Control 按下 `ctrl+`` 复制粘贴以下代码 12`import urllib.request,os,hashlib; h = &apos;eb2297e1a458f27d836c04bb0cbaf282&apos; + &apos;d0e7a3098092775ccb37ca9d6b2e4b7d&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest();print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)` 安装sublime3插件 按下 ctrl+shift+p，输入’ip’（Install Package） 输入以下插件的名字，按顺序逐个进行安装： EditorConfig Sass SublimeLinter SublimeLinter-jscs SublimeLinter-jshint SublimeLinter-csslint SublimeLinter-contrib-scss-lint JSFormat CSScomb 插件的配置文件将以下配置文件分别下载后放入项目根目录下： EditorConfig配置文件 JSCS配置文件 JSHint配置文件 注意：全局变量需要手动加到配置文件的globals属性里，例： 12345&#123; &quot;globals&quot;: &#123; &quot;ImageHandle&quot;: true &#125;&#125; CSSLint配置文件 SCSS-Lint配置文件 编辑器及插件设置 sublime3 自身 Preferences-&gt;Setting-User，增加下面两个配置：1234&#123; &quot;translate_tabs_to_spaces&quot;: true, &quot;word_wrap&quot;: true&#125; 点击右下角的Spaces-&gt;Convert Indentation to Spaces可以将文件中的所有tab转换成空格 JSFormat Preferences-&gt;Package Settings-&gt;JSFormat-&gt;Setting-User，下载配置文件覆盖 配置好后格式化的默认快捷键是 ctrl+alt+f SublimeLinter 右键-&gt;SublimeLinter-&gt;Lint Mode，有4种检查模式，建议选择 Load/save 右键-&gt;SublimeLinter-&gt;Mark Style，建议选择 Outline 右键-&gt;SublimeLinter-&gt;Choose Gutter Theme，建议选择 Blueberry-round 右键-&gt;SublimeLinter-&gt;Open User Settings，将linter里面jscs的args改成 [&quot;--verbose&quot;]，将linter里面csslint的ignore改成 &quot;box-model,adjoining-classes,box-sizing,compatible-vendor-prefixes,gradients,text-indent,fallback-colors,star-property-hack,underscore-property-hack,bulletproof-font-face,font-faces,import,regex-selectors,universal-selector,unqualified-attributes,overqualified-elements,duplicate-background-images,floats,font-sizes,ids,important,outline-none,qualified-headings,unique-headings&quot; 当光标处于有错误的代码行时，详细的错误信息会显示在下面的状态栏中 右键-&gt;SublimeLinter可以看到所有的快捷键，其中 ctrl+k, a 可以列出所有错误 CSScomb Preferences-&gt;Package Settings-&gt;CSScomb-&gt;Setting-User，下载配置文件覆盖 配置好后格式化的默认快捷键是 ctrl+shift+c grunt插件在项目中安装grunt插件jscs npm install grunt-jscs --save-dev jshint npm install grunt-contrib-jshint --save-devcsslint npm install grunt-contrib-csslint --save-dev scss-lint npm install grunt-scss-lint --save-dev 插件的配置文件 JSCS 123456789&#123; options: &#123; config: true, verbose: true &#125;, files: &#123; src: [...] &#125;&#125; JSHint 12345678&#123; options: &#123; jshintrc: true &#125;, files: &#123; src: [...] &#125;&#125; CSSLint 12345678&#123; options: &#123; csslintrc: &apos;.csslintrc&apos; &#125;, files: &#123; src: [...] &#125;&#125; SCSS-Lint 12345678&#123; options: &#123; config: &apos;.scss-lint.yml&apos; &#125;, files: &#123; src: [...] &#125;&#125;","tags":[{"name":"sublime","slug":"sublime","permalink":"http://yoursite.com/tags/sublime/"},{"name":"编辑器","slug":"编辑器","permalink":"http://yoursite.com/tags/编辑器/"}]},{"title":"必备的7个JavaScript函数","date":"2016-07-21T16:00:00.000Z","path":"/template/20160722/js-function/","text":"防止高频调用的debounce函数debounce 函数对于那些执行事件驱动的任务来说是必不可少的提高性能的函数。如果你在使用scroll, resize, key*等事件触发执行任务时不使用降频函数，也行你就犯了重大的错误。下面这个降频函数 debounce 能让你的代码变的高效： 12345678910111213141516171819function debounce(func, wait, immediate) &#123; var timeout; return function() &#123; var context = this, args = arguments; var later = function() &#123; timeout = null; if (!immediate) func.apply(context, args); &#125;; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); &#125;;&#125;;var myEfficientFn = debounce(function() &#123; // All the taxing stuff you do&#125;, 250);window.addEventListener(&apos;resize&apos;, myEfficientFn); 这个 debounce 函数在给定的时间间隔内只允许你提供的回调函数执行一次，以此降低它的执行频率。当遇到高频触发的事件时，这样的限制显得尤为重要。 设定时间/频率循环检测函数上面提到的 debounce 函数是借助于某个事件的触发。但有时候并没有这样的事件可用，那我们只能自己写一个函数来每隔一段时间检查一次。 12345678910111213function poll (fn, callback, err, timeout, interval) &#123; var startTime = (new Date()).getTime(); var pi = window.setInterval(function()&#123; if (Math.floor(((new Date).getTime() - startTime) / 1000) &lt;= timeout) &#123; if (fn()) &#123; callback(); &#125; &#125; else &#123; window.clearInterval(pi); err(); &#125; &#125;, interval)&#125; 禁止重复调用、只允许执行一次的once 函数很多时候，我们只希望某种动作只能执行一次，就像是我们使用 onload 来限定只在加载完成时执行一次。下面这个函数就能让你的操作执行一次后就不会再重复执行。 1234567891011121314151617181920function once(fn, context) &#123; var result; return function() &#123; if(fn) &#123; result = fn.apply(context || this, arguments); fn = null; &#125; return result; &#125;;&#125;// Usagevar canOnlyFireOnce = once(function() &#123; console.log(&apos;Fired!&apos;);&#125;);canOnlyFireOnce(); // &quot;Fired!&quot;canOnlyFireOnce(); // nada 获取一个链接的绝对地址 getAbsoluteUrl获取链接的绝对地址并不像你想象的那么简单。下面就是一个非常实用的函数，能根据你输入的相对地址，获取绝对地址：var getAbsoluteUrl = (function() { var a; return function(url) { if(!a) a = document.createElement(&apos;a&apos;); a.href = url; return a.href; }; })(); // UsagegetAbsoluteUrl(‘/something’); // http://www.webhek.com/something 判断一个JavaScript函数是否是系统原生函数 isNative很多第三方js脚本都会在全局变量里引入新的函数，有些甚至会覆盖掉系统的原生函数，下面这个方法就是来检查是不是原生函数的： 1234567891011121314151617181920212223;(function() &#123; var toString = Object.prototype.toString; var fnToString = Function.prototype.toString; var reHostCtor = /^\\[object .+?Constructor\\]$/; var reNative = RegExp(&apos;^&apos; + String(toString) .replace(/[.*+?^$&#123;&#125;()|[\\]\\/\\\\]/g, &apos;\\\\$&amp;&apos;) .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, &apos;$1.*?&apos;) + &apos;$&apos; ); function isNative(value) &#123; var type = typeof value; return type == &apos;function&apos; ? reNative.test(fnToString.call(value)) : (value &amp;&amp; type == &apos;object&apos; &amp;&amp; reHostCtor.test(toString.call(value))) || false; &#125; module.exports = isNative;&#125;());// UsageisNative(alert); // trueisNative(myCustomFunction); // false 用JavaScript创建新的CSS规则 insertRule有时候我们会使用一个CSS选择器(比如 document.querySelectorAll)来获取一个 NodeList ，然后给它们每个依次修改样式。其实这并不是一种高效的做法，高效的做法是用JavaScript新建一段CSS样式规则： 123456789Sheet = (function() &#123; var style = document.createElement(&apos;style&apos;); style.setAttribute(&apos;media&apos;, &apos;screen&apos;); style.appendChild(document.createTextNode(&apos;&apos;)); document.head.appendChild(style); return function(rule)&#123; style.sheet.insertRule( rule, style.sheet.cssRules.length ); &#125; ;&#125;)();Sheet(&quot;.stats &#123; position: relative ; top: 0px &#125;&quot;) ; 这些做法的效率非常高，在一些场景中，比如使用ajax新加载一段html时，使用上面这个方法，你不需要操作新加载的html内容。 判断网页元素是否具有某种属性和样式 matchesSelector12345678910function matchesSelector(el, selector) &#123; var p = Element.prototype; var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function(s) &#123; return [].indexOf.call(document.querySelectorAll(s), this) !== -1; &#125;; return f.call(el, selector);&#125;// UsagematchesSelector(document.getElementById(&apos;myDiv&apos;), &apos;div.someSelector[some-attribute=true]&apos;)","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"搞定git分支","date":"2016-05-09T16:00:00.000Z","path":"/template/20160510/git-master/","text":"查看远程分支 12345678$ git branch -a * br-2.1.2.2 master remotes/origin/HEAD -&gt; origin/master remotes/origin/br-2.1.2.1 remotes/origin/br-2.1.2.2 remotes/origin/br-2.1.3 remotes/origin/master 查看本地分支 123$ git branch -a * br-2.1.2.2 master 创建分支 12345$ git branch test $ git branch * br-2.1.2.2 master test 把分支推到远程分支 1$ git push origin test 切换分支到test 1234567891011121314$ git branch * br-2.1.2.2 master test $ git checkout test M Shoestrong-server/src/main/java/com/taobao/Shoestrong/server/service/cmd/GetCustomerTarCmd.java M Shoestrong-server/src/main/java/com/taobao/Shoestrong/server/util/ServerUtil.java Switched to branch &apos;test&apos; $ git branch br-2.1.2.2 master * test M 表示cong 原来分支（上一次修改没有提交br-2.1.2.2）带过来的修改 删除本地分支 git branch -d xxxxx 12345678910111213141516$ git checkout br-2.1.2.2 M Shoestrong-server/src/main/java/com/taobao/Shoestrong/server/service/cmd/GetCustomerTarCmd.java M Shoestrong-server/src/main/java/com/taobao/Shoestrong/server/util/ServerUtil.java Switched to branch &apos;br-2.1.2.2&apos; $ git br * br-2.1.2.2 master test $ git br -d test Deleted branch test (was 17d28d9). $ git br * br-2.1.2.2 master 查看本地和远程分支 -a。前面带*号的代表你当前工作目录所处的分支 1remotes/origin/HEAD -&gt; origin/master #啥意思呢？ ”在clone完成之后，Git 会自动为你将此远程仓库命名为origin（origin只相当于一个别名，运行git remote –v或者查看.git\\/config可以看到origin的含义），并下载其中所有的数据，建立一个指向它的master 分支的指针，我们用(远程仓库名)\\/(分支名) 这样的形式表示远程分支，所以origin\\/master指向的是一个remote branch（从那个branch我们clone数据到本地）“这个是执行 git remote -v 的结果，看出来origin其实就是远程的git地址的一个别名。 123$ git remote -v origin git@xxxx/Shoestrong.git (fetch) origin git@xxxx/Shoestrong.git (push) 123456789$ git branch -a br-2.1.2.2 master * test remotes/origin/HEAD -&gt; origin/master remotes/origin/br-2.1.2.1 remotes/origin/br-2.1.2.2 remotes/origin/br-2.1.3 remotes/origin/master 删除远程版本 1git push origin :br-1.0.0 删除远程分支 12git branch -r -d origin/branch-name git push origin :branch-name","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"node.js建立个简单的web服务器","date":"2016-04-14T16:00:00.000Z","path":"/template/20160415/node-webserver/","text":"接触nodejs还不算太多，欠缺的知识方面很多。 就来试着搭建一下，废话少说直接上代码： cmd: 123cd ./myServer &lt;自己的文件目录&gt;node server.js &lt;直接node下运行server.js&gt; server.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// 这是一个简单的Node HTTP服务器,能处理当前目录的文件// 并能实现两种特殊的URL用于测试// 用HTTP://localhost:4000或http://127.0.0.1:4000连接这个服务器// 首先加载所有需要用到的模块var http = require('http'); // Http服务器APIvar fs = require('fs'); // 用于处理本地文件var server = new http.Server(); // 创建新的HTTP服务器server.listen(4000); // 监听端口4000// 使用on方法注册时间处理server.on('request', function(request, response) &#123; // 当有request请求的时候触发处理函数 console.log('Request'); // 解析请求的URL var url = require('url').parse(request.url); // 特殊URL会让服务器在发送响应前先等待 switch(url.pathname) &#123; case ''||'/' : // 模拟欢迎页,nodejs是高效流处理的方案,也可以通过配置文件来配置 fs.readFile('./index.html', function(err, content)&#123; if(err) &#123; response.writeHead(404, &#123; 'Content-Type':'text/plain; charset=\"UTF-8\"' &#125;); response.write(err.message); response.end(); &#125; else &#123; response.writeHead(200, &#123; 'Content-Type' : 'text/html; charset=UTF-8' &#125;); response.write(content); response.end(); &#125; &#125;); break; case '/test/delay':// 此处用于模拟缓慢的网络连接 // 使用查询字符串来获取延迟时长,或者2000毫秒 var delay = parseInt(url.query) || 2000; // 设置响应状态和头 response.writeHead(200, &#123;'Content-type':'text/plain; charset=UTF-8'&#125;); // 立即开始编写响应主体 response.write('Sleeping for' + delay + ' milliseconds...'); // 在之后调用的另一个函数中完成响应 setTimeout(function()&#123; response.write('done.'); response.end(); &#125;, delay); break; case '/test/mirror':// 如果请求是test/mirror,则原文返回它 // 响应状态和头 response.writeHead(200, &#123;'Content-type':'text/plain; charset=UTF-8'&#125;); // 用请求的内容开始编写响应主体 response.write(request.mothod + ' ' + request.url + ' HTTP/' + request.httpVersion + '\\r\\n'); // 所有的请求头 for (var h in request.headers) &#123; response.write(h + ':' + request.headers[h] + '\\r\\n'); &#125; response.write('\\r\\n');// 使用额外的空白行来结束头 // 在这些事件处理程序函数中完成响应 // 当请求主体的数据块完成时,把其写入响应中 request.on('data', function(chunk) &#123; response.write(chunk); &#125;); // 当请求结束时,响应也完成 request.on('end', function(chunk)&#123; response.end(); &#125;); break; case '/json' : // 模拟JSON数据返回 // 响应状态和头 response.writeHead(200, &#123;'Content-type':'application/json; charset=UTF-8'&#125;); response.write(JSON.stringify(&#123;test:'success'&#125;)); response.end(); break; default:// 处理来自本地目录的文件 var filename = url.pathname.substring(1); // 去掉前导'/' var type = getType(filename.substring(filename.lastIndexOf('.')+1)); // 异步读取文件,并将内容作为单独的数据模块传给回调函数 // 对于确实很大的文件,使用流API fs.createReadStream()更好 fs.readFile(filename, function(err, content)&#123; if(err) &#123; response.writeHead(404, &#123; 'Content-Type':'text/plain; charset=\"UTF-8\"' &#125;); response.write(err.message); response.end(); &#125; else &#123; response.writeHead(200, &#123; 'Content-Type' : type &#125;); response.write(content); response.end(); &#125; &#125;); break; &#125; &#125;);function getType(endTag)&#123; var type=null; switch(endTag)&#123; case 'html' : case 'htm' : type = 'text/html; charset=UTF-8'; break; case 'js' : type = 'application/javascript; charset=\"UTF-8\"'; break; case 'css' : type = 'text/css; charset=\"UTF-8\"'; break; case 'txt' : type = 'text/plain; charset=\"UTF-8\"'; break; case 'manifest' : type = 'text/cache-manifest; charset=\"UTF-8\"'; break; default : type = 'application/octet-stream'; break; &#125; return type;&#125;//向控制台输出服务启动的信息 console.log('[WebServer][Start] running at http://localhost:4000'); 在localhost:4000预览就OK了。","tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"jQuery.extend扩展","date":"2016-04-01T16:00:00.000Z","path":"/template/20160402/jquery-extend/","text":"jQuery.extend 对jQuery本身的属性和方法进行了扩展、（相当于添加静态方法），也可以扩展对象，是否实行深度拷贝(第一个参数决定).jQuery.fn.extend 对jQuery.fn的属性和方法进行了扩展（相当于添加成员方法） 源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364jQuery.extend = jQuery.fn.extend = function() &#123; var src, copyIsArray, copy, name, options, clone, target = arguments[0] || &#123;&#125;, // 常见用法 jQuery.extend( obj1, obj2 )，此时，target为arguments[0] i = 1, length = arguments.length, deep = false; // Handle a deep copy situation if ( typeof target === &quot;boolean&quot; ) &#123; // 如果第一个参数为true，即 jQuery.extend( true, obj1, obj2 ); 的情况 deep = target; // 此时target是true target = arguments[1] || &#123;&#125;; // target改为 obj1 // skip the boolean and the target i = 2; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target) ) &#123; // 处理奇怪的情况，比如 jQuery.extend( &apos;hello&apos; , &#123;nick: &apos;casper&#125;)~~ target = &#123;&#125;; &#125; // extend jQuery itself if only one argument is passed if ( length === i ) &#123; // 处理这种情况 jQuery.extend(obj)，或 jQuery.fn.extend( obj ) target = this; // jQuery.extend时，this指的是jQuery；jQuery.fn.extend时，this指的是jQuery.fn --i; &#125; for ( ; i &lt; length; i++ ) &#123; // Only deal with non-null/undefined values if ( (options = arguments[ i ]) != null ) &#123; // 比如 jQuery.extend( obj1, obj2, obj3, ojb4 )，options则为 obj2、obj3... // Extend the base object for ( name in options ) &#123; src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) &#123; // 防止自引用，不赘述 continue; &#125; // Recurse if we&apos;re merging plain objects or arrays // 如果是深拷贝，且被拷贝的属性值本身是个对象 if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) &#123; if ( copyIsArray ) &#123; // 被拷贝的属性值是个数组 copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; &#125; else &#123; 被拷贝的属性值是个plainObject，比如&#123; nick: &apos;casper&apos; &#125; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // 递归~ // Don&apos;t bring in undefined values &#125; else if ( copy !== undefined ) &#123; // 浅拷贝，且属性值不为undefined target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;;","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"创建对象的方法与实践","date":"2016-02-09T16:00:00.000Z","path":"/template/20160210/create-object/","text":"创建自变量创建对象最简单的方法，对象字面量。JavaScript总是宣扬自己能够“无中生有”地创建对象——不需要类、不需要模板、不需要原型——“噌”地一下，一个有方法有数据的对象就出现了。 123456var o = &#123; x: 42, y: 3.14, f: function() &#123;&#125;, g: function() &#123;&#125;&#125;; 缺点：如果我们想在其他地方创建一个同类型的对象，就得把这个对象的方法、数据和初始化都复制粘贴过去。我们需要一种能够批量创建同类型对象的方法，而不是只创建一个对象。 工厂函数这种方法来创建一类具有相同结构、接口和实现的对象是最简单的。我们不直接创建一个对象字面量，而是将对象字面量作为函数的返回值，当我们需要多次或多处创建同类型的对象时，只要调用这个函数就行了。 123456789function thing() &#123; return &#123; x: 42, y: 3.14, f: function() &#123;&#125;, g: function() &#123;&#125; &#125;;&#125;var o = thing(); 缺点：它会导致内存膨胀，因为每一个对象都包含了工厂函数的独立副本。理论上我们希望所有对象共享一个工厂函数副本。 原型链JavaScript提供了一种内置的在对象之间共享数据的机制，叫做原型链。当我们访问一个对象的属性时，它会委托某些其他对象来完成这一请求。我们可以利用这一点来修改工厂函数，使它创建的每个对象只包含自己特有的数据，而对其他属性的请求则全部委托给原型链上共有的一个对象。 1234567891011var thingPrototype = &#123; f: function() &#123;&#125;, g: function() &#123;&#125;&#125;;function thing() &#123; var o = Object.create(thingPrototype); o.x = 42; o.y = 3.14; return o;&#125;var o = thing(); 事实上，JavaScript本身就有内置的机制来支持这种通用模式。我们不需要自己创建这个共有的对象（即原型对象），JavaScript会自动为每个函数创建一个原型对象，我们可以把共享数据直接放在这个对象里。 123456789thing.prototype.f = function() &#123;&#125;;thing.prototype.g = function() &#123;&#125;;function thing() &#123; var o = Object.create(thing.prototype); o.x = 42; o.y = 3.14; return o;&#125;var o = thing(); 缺点：会导致重复。上述thing函数的第一行和最后一行在每一个“委托原型的工厂函数”中都会重复一次，几乎没有区别。 ES5我们可以把那些重复的代码抽出来，放进一个自定义函数里。这个函数会创建一个对象，并与其他某个任意函数（参数函数）的原型建立委托(继承)关系，然后我们把新创建的对象作为参数，调用这个函数（参数函数），最后返回这个新的对象。 123456789101112function create(fn) &#123; var o = Object.create(fn.prototype); fn.call(o); return o;&#125;Thing.prototype.f = function() &#123;&#125;;Thing.prototype.g = function() &#123;&#125;;function Thing() &#123; this.x = 42; this.y = 3.14;&#125;var o = create(Thing); 事实上，JavaScript对这种方法也有内置的支持机制。我们定义的这个create函数实际上就是new关键字的一个基本实现，因此我们可以顺手把create换成new。 1234567Thing.prototype.f = function() &#123;&#125;;Thing.prototype.g = function() &#123;&#125;;function Thing() &#123; this.x = 42; this.y = 3.14;&#125;var o = new Thing(); 我们现在抵达的这一站通常被称为ES5类。它通过函数来创建对象，把需要共享的数据委托给原型对象，并使用new关键字来处理重复的逻辑。缺点：冗长又难看，而且在实现继承的时候会更冗长更难看。 ES6JavaScript最新的相关改进是ES6 类，用新语法来实现上述功能要简洁得多。 123456789class Thing &#123; constructor() &#123; this.x = 42; this.y = 3.14; &#125; f() &#123;&#125; g() &#123;&#125;&#125;var o = new Thing(); 比较多年以来，JavaScript开发者们与原型链的关系总是若即若离，纠缠不清。而今天我们最有可能遇到的两种创建对象的方式，一种是强烈依赖原型链的class语法，另一种则是完全不依赖原型链的工厂函数语法。这两种方式在性能上和特点上是不一样的——尽管差别不太大。 性能今天的JavaScript引擎已经经过了大幅度的优化，以至于很难通过JavaScript代码来推断怎样会比较快。关键在于测量方法。然而测量方法有时也会失灵。通常每六周就会有更新的JavaScript引擎发布，而在这之前采取的测量方法，和基于这种测量方法做出的决策都有可能失去意义。因此，我的经验法则是选择最官方、最广泛使用的语法，因为大多数时候它经历的实践检验最多，因而性能是最高的。目前来说class语法最符合这一点，在我写这篇文章时，class语法大约比返回字面量的工厂函数快3倍。 特点随着ES6的发布，类与工厂函数之间曾经存在的几点差异消失了。现在，工厂函数和类都能够强制实现真正的私有数据——工厂函数通过闭包实现，类通过WeakMap实现。两者都能实现多重继承——工厂函数可以将其他属性混入自己的对象，类也可以将其他属性混入自己的原型，或者通过类工厂，通过代理也能实现。工厂函数和类也都可以在需要的时候返回任意对象，语法也都很简单。结论综合考虑，我更倾向于class语法。它标准、简单、干净、快速，还提供了所有曾经只有函数工厂才具备的特点。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"检测IE浏览器版本","date":"2016-01-27T16:00:00.000Z","path":"/template/20160128/IE-solve/","text":"一般来说，我们是建议使用条件注释来替换浏览器检测的方法。本文所讲的技术仅仅在条件注释无法实现，或者需要检测一个bug。 IE条件注释： IE10及其以下的浏览器可以通过检测存在非标准的 document.all 对象来区分。 除了上面的特性外，每个IE浏览器还有各自的支持对象 IE版本 支持的标准对象 10+ window.atob 9+ document.addEventListener 8+ document.querySelector 7+ window.XMLHttpRequest 6+ document.compatMode 通过上面列出的这些不同IE浏览器版本的检测特性，我们可以组合得到某个特定的IE版本 例如下面的这些组合 IE版本 支持的状态 10及以下 document.all 9及以下 document.all &amp;&amp; !window.atob 8及以下 document.all &amp;&amp; !document.addEventListener 7及以下 document.all &amp;&amp; !document.querySelector 6及以下 document.all &amp;&amp; !window.XMLHttpRequest 5.x document.all &amp;&amp; !document.compatMode 例子 下面的条件代码只会在IE7及一下浏览器中运行 if (document.all &amp;&amp; !document.querySelector) {alert(‘IE7 or lower’);} 下面这一个只会运行在IE8中，并且不支持IE7或者IE9： if (document.all &amp;&amp; document.querySelector &amp;&amp; !document.addEventListener) {alert(‘IE8’);} 下面的条件代码当浏览器为IE11+ 或者非IE时为真 if (!document.all) {alert(‘IE11+ or not IE’);} 其他方法检测IE版本 由于IE11并不再支持条件注释了 检测不同的IE版本对应不同的javascript引擎 |IE版本 | - | 10 | 9 | 8 | 7 | 6 ||JavaScript引擎版本 | - | 10 | 9 | 5.8 | 5.7 | 5.6 | 条件注释例如下面的代码结合条件注释和JS代码： html代码： var ie = false; 在JavaScript文件中： if (7 === ie) {alert(‘IE7 or lower’);} 或者是： var test = document.createElement(‘div’);test.innerHTML = ‘‘; if (‘1’ === test.innerHTML) {alert(‘IE7 or lower’);} 相比较使用全局方法，这种方法可能就不优雅并且速度也不是很快。 IE版本代码总结： IE11或者非IE if (!document.all) {alert(‘IE11+ or not IE’);} IE10 if (document.all &amp;&amp; document.addEventListener &amp;&amp; window.atob) {alert(‘IE10’);} IE9 if (document.all &amp;&amp; document.addEventListener &amp;&amp; !window.atob) {alert(‘IE9’);}IE8上面已经给出 if (document.all &amp;&amp; document.querySelector &amp;&amp; !document.addEventListener) {alert(‘IE8’);} IE7 if (document.all &amp;&amp; window.XMLHttpRequest &amp;&amp; !document.querySelector) {alert(‘IE7’);} IE6 if (document.all &amp;&amp; document.compatMode &amp;&amp; !window.XMLHttpRequest) {alert(‘IE6’);}","tags":[{"name":"IE","slug":"IE","permalink":"http://yoursite.com/tags/IE/"}]},{"title":"jquery 小片段","date":"2015-12-22T16:00:00.000Z","path":"/template/20151223/jquery-bits/","text":"检测IE浏览器12345$(document).ready(function() &#123; if(navigator.userAgent.match(/msie/i)) &#123; alert(&apos;I am an old fashioned Internet Explorer&apos;); &#125;&#125;); 平滑滚动至页面顶部123456$(&quot;a[href=&apos;#top&apos;]&quot;).click(function() &#123; $(&quot;html, body&quot;).animate(&#123; scrollTop: 0 &#125;, &quot;slow&quot;); return false;&#125;); 保持始终处于顶部1234567891011121314151617181920$(function() &#123;var $win = $(window);var $nav = $(&apos;.mytoolbar&apos;);var navTop = $(&apos;.mytoolbar&apos;).length &amp;&amp; $(&apos;.mytoolbar&apos;).offset().top;var isFixed = 0;processScroll()$win.on(&apos;scroll&apos;, processScroll)function processScroll() &#123; var i, scrollTop = $win.scrollTop() if(scrollTop &gt;= navTop &amp;&amp; !isFixed) &#123; isFixed = 1 $nav.addClass(&apos;subnav-fixed&apos;) &#125; else if(scrollTop &lt;= navTop &amp;&amp; isFixed) &#123; isFixed = 0 $nav.removeClass(&apos;subnav-fixed&apos;) &#125;&#125;&#125;) 替换html标签123$(&apos;li&apos;).replaceWith(function() &#123; return $(&quot;&lt;div /&gt;&quot;).append($(this).contents());&#125;); 检测小屏幕宽度12345var responsive_viewport = $(window).width();/* 如果小于 481px */if(responsive_viewport &lt; 481) &#123; alert(&apos;屏幕小于481px&apos;);&#125; /* 属于小屏 */ 自动修复损坏图片123$(&apos;img&apos;).error(function() &#123; $(this).attr(&apos;src&apos;, &apos;img/broken.png&apos;);&#125;); 检测复制、 粘贴与剪切操作123456789$(&quot;#textA&quot;).bind(&apos;copy&apos;, function() &#123; $(&apos;span&apos;).text(&apos;copy behaviour detected!&apos;)&#125;);$(&quot;#textA&quot;).bind(&apos;paste&apos;, function() &#123; $(&apos;span&apos;).text(&apos;paste behaviour detected!&apos;)&#125;);$(&quot;#textA&quot;).bind(&apos;cut&apos;, function() &#123; $(&apos;span&apos;).text(&apos;cut behaviour detected!&apos;)&#125;); 自动为外部链接添加target = “blank” 属性1234var root = location.protocol + &apos;//&apos; + location.host;$(&apos;a&apos;).not(&apos;:contains(root)&apos;).click(function() &#123; this.target = &quot;_blank&quot;;&#125;); 悬停时淡入 / 淡出12345678$(document).ready(function() &#123; $(&quot;.thumbs img&quot;).fadeTo(&quot;slow&quot;, 0.6); // This sets the opacity of the thumbs to fade down to 60% when the page loads $(&quot;.thumbs img&quot;).hover(function() &#123; $(this).fadeTo(&quot;slow&quot;, 1.0); // This should set the opacity to 100% on hover &#125;, function() &#123; $(this).fadeTo(&quot;slow&quot;, 0.6); // This should set the opacity back to 60% on mouseout &#125;);&#125;); 禁用文本 / 密码输入中的空格12345$(&apos;input.nospace&apos;).keydown(function(e) &#123; if(e.keyCode == 32) &#123; return false; &#125;&#125;);","tags":[{"name":"jquery","slug":"jquery","permalink":"http://yoursite.com/tags/jquery/"}]},{"title":"Javascript 面向对象编程","date":"2015-11-21T16:00:00.000Z","path":"/template/20151122/js-object-oriented/","text":"我们知道Javascript中的变量定义基本如下： 123456789var name = &apos;Chen Hao&apos;;var email = &apos;haoel(@)hotmail.com&apos;;var website = &apos;http://coolshell.cn&apos;; 如果要用对象来写的话，就是下面这个样子：var chenhao = &#123; name : &apos;Chen Hao&apos;, email : &apos;haoel(@)hotmail.com&apos;, website : &apos;http://coolshell.cn&apos;&#125;; 于是，我就可以这样访问： 12345678//以成员的方式chenhao.name;chenhao.email;chenhao.website;//以hash map的方式chenhao[&quot;name&quot;];chenhao[&quot;email&quot;];chenhao[&quot;website&quot;]; 关于函数，我们知道Javascript的函数是这样的： 123var doSomething = function()&#123; alert(&apos;Hello World.&apos;);&#125;; 于是，我们可以这么干： 123456789var sayHello = function()&#123; var hello = &quot;Hello, I&apos;m &quot;+ this.name + &quot;， my email is: &quot; + this.email + &quot;， my website is: &quot; + this.website; alert(hello);&#125;;//直接赋值，这里很像C/C++的函数指针chenhao.Hello = sayHello;chenhao.Hello(); 相信这些东西都比较简单，大家都明白了。 可以看到Javascript对象函数是直接声明，直接赋值，直接就用了。runtime的动态语言。还有一种比较规范的写法是： 1234567891011121314//我们可以看到， 其用function来做class。var Person = function(name, email, website)&#123; this.name = name; this.email = email; this.website = website; this.sayHello = function()&#123; var hello = &quot;Hello, I&apos;m &quot;+ this.name + &quot;， \\n&quot; + &quot;my email is: &quot; + this.email + &quot;， \\n&quot; + &quot;my website is: &quot; + this.website; alert(hello); &#125;;&#125;;var chenhao = new Person(&quot;Chen Hao&quot;, &quot;haoel@hotmail.com&quot;,&quot;http://coolshell.cn&quot;);chenhao.sayHello(); 顺便说一下，要删除对象的属性，很简单： 1delete chenhao[&apos;email&apos;] 上面的这些例子，我们可以看到这样几点：Javascript的数据和成员封装很简单。没有类完全是对象操作。纯动态！Javascript function中的this指针很关键，如果没有的话，那就是局部变量或局部函数。Javascript对象成员函数可以在使用时临时声明，并把一个全局函数直接赋过去就好了。Javascript的成员函数可以在实例上进行修改，也就是说不同实例相同函数名的行为不一定一样。 属性配置 – Object.defineProperty先看下面的代码： 123456789101112131415161718192021//创建对象var chenhao = Object.create(null);//设置一个属性Object.defineProperty( chenhao, &apos;name&apos;, &#123; value: &apos;Chen Hao&apos;, writable: true, configurable: true, enumerable: true &#125;);//设置多个属性Object.defineProperties( chenhao, &#123; &apos;email&apos; : &#123; value: &apos;haoel@hotmail.com&apos;, writable: true, configurable: true, enumerable: true &#125;, &apos;website&apos;: &#123; value: &apos;http://coolshell.cn&apos;, writable: true, configurable: true, enumerable: true &#125; &#125;); 下面就说说这些属性配置是什么意思。writable：这个属性的值是否可以改。configurable：这个属性的配置是否可以改。enumerable：这个属性是否能在for…in循环中遍历出来或在Object.keys中列举出来。value：属性值。get()/set(_value)：get和set访问器。Get/Set 访问器关于get/set访问器，它的意思就是用get/set来取代value（其不能和value一起使用），示例如下： 1234567891011var age = 0;Object.defineProperty( chenhao, &apos;age&apos;, &#123; get: function() &#123; return age+1; &#125;, set: function(value) &#123; age = value; &#125; enumerable : true, configurable : true &#125;);chenhao.age = 100; //调用setalert(chenhao.age); //调用get 输出101（get中+1了）; 我们再看一个更为实用的例子——利用已有的属性(age)通过get和set构造新的属性(birth_year)： 123456789101112131415161718Object.defineProperty( chenhao, &apos;birth_year&apos;, &#123; get: function() &#123; var d = new Date(); var y = d.getFullYear(); return ( y - this.age ); &#125;, set: function(year) &#123; var d = new Date(); var y = d.getFullYear(); this.age = y - year; &#125; &#125;);alert(chenhao.birth_year);chenhao.birth_year = 2000;alert(chenhao.age); 这样做好像有点麻烦，你说，我为什么不写成下面这个样子： 12345678910111213141516171819var chenhao = &#123; name: &quot;Chen Hao&quot;, email: &quot;haoel@hotmail.com&quot;, website: &quot;http://coolshell.cn&quot;, age: 100, get birth_year() &#123; var d = new Date(); var y = d.getFullYear(); return ( y - this.age ); &#125;, set birth_year(year) &#123; var d = new Date(); var y = d.getFullYear(); this.age = y - year; &#125;&#125;;alert(chenhao.birth_year);chenhao.birth_year = 2000;alert(chenhao.age); 是的，你的确可以这样的，不过通过defineProperty()你可以干这些事：1）设置如 writable，configurable，enumerable 等这类的属性配置。2）动态地为一个对象加属性。比如：一些HTML的DOM对像。 查看对象属性配置如果查看并管理对象的这些配置，下面有个程序可以输出对象的属性和配置等东西： 123456789101112131415161718//列出对象的属性.function listProperties(obj)&#123; var newLine = &quot;&lt;br /&gt;&quot;; var names = Object.getOwnPropertyNames(obj); for (var i = 0; i &lt; names.length; i++) &#123; var prop = names[i]; document.write(prop + newLine); // 列出对象的属性配置（descriptor）动用getOwnPropertyDescriptor函数。 var descriptor = Object.getOwnPropertyDescriptor(obj, prop); for (var attr in descriptor) &#123; document.write(&quot;...&quot; + attr + &apos;: &apos; + descriptor[attr]); document.write(newLine); &#125; document.write(newLine); &#125;&#125;listProperties(chenhao); call, apply, bind 和 this关于Javascript的this指针，和C++/Java很类似。 我们来看个示例：（这个示例很简单了，我就不多说了） 123456789function print(text)&#123; document.write(this.value + &apos; - &apos; + text+ &apos;&lt;br&gt;&apos;);&#125;var a = &#123;value: 10, print : print&#125;;var b = &#123;value: 20, print : print&#125;;print(&apos;hello&apos;);// this =&gt; global, output &quot;undefined - hello&quot;a.print(&apos;a&apos;);// this =&gt; a, output &quot;10 - a&quot;b.print(&apos;b&apos;); // this =&gt; b, output &quot;20 - b&quot;a[&apos;print&apos;](&apos;a&apos;); // this =&gt; a, output &quot;10 - a&quot; 我们再来看看call 和 apply，这两个函数的差别就是参数的样子不一样，另一个就是性能不一样，apply的性能要差很多。（关于性能，可到 JSPerf 上去跑跑看看） 1234print.call(a, &apos;a&apos;); // this =&gt; a, output &quot;10 - a&quot;print.call(b, &apos;b&apos;); // this =&gt; b, output &quot;20 - b&quot;print.apply(a, [&apos;a&apos;]); // this =&gt; a, output &quot;10 - a&quot;print.apply(b, [&apos;b&apos;]); // this =&gt; b, output &quot;20 - b&quot; 但是在bind后，this指针，可能会有不一样，但是因为Javascript是动态的。如下面的示例 1234var p = print.bind(a);p(&apos;a&apos;); // this =&gt; a, output &quot;10 - a&quot;p.call(b, &apos;b&apos;); // this =&gt; a, output &quot;10 - b&quot;p.apply(b, [&apos;b&apos;]); // this =&gt; a, output &quot;10 - b&quot; 继承 和 重载通过上面的那些示例，我们可以通过Object.create()来实际继承，请看下面的代码，Student继承于Object。 123456789101112131415161718192021222324252627282930313233343536var Person = Object.create(null);Object.defineProperties( Person, &#123; &apos;name&apos; : &#123; value: &apos;Chen Hao&apos;&#125;, &apos;email&apos; : &#123; value : &apos;haoel@hotmail.com&apos;&#125;, &apos;website&apos;: &#123; value: &apos;http://coolshell.cn&apos;&#125; &#125;);Person.sayHello = function () &#123; var hello = &quot;&lt;p&gt;Hello, I am &quot;+ this.name + &quot;， &lt;br&gt;&quot; + &quot;my email is: &quot; + this.email + &quot;， &lt;br&gt;&quot; + &quot;my website is: &quot; + this.website; document.write(hello + &quot;&lt;br&gt;&quot;);&#125;var Student = Object.create(Person);Student.no = &quot;1234567&quot;; //学号Student.dept = &quot;Computer Science&quot;; //系//使用Person的属性document.write(Student.name + &apos; &apos; + Student.email + &apos; &apos; + Student.website +&apos;&lt;br&gt;&apos;);//使用Person的方法Student.sayHello();//重载SayHello方法Student.sayHello = function (person) &#123; var hello = &quot;&lt;p&gt;Hello, I am &quot;+ this.name + &quot;， &lt;br&gt;&quot; + &quot;my email is: &quot; + this.email + &quot;， &lt;br&gt;&quot; + &quot;my website is: &quot; + this.website + &quot;， &lt;br&gt;&quot; + &quot;my student no is: &quot; + this. no + &quot;， &lt;br&gt;&quot; + &quot;my departent is: &quot; + this. dept; document.write(hello + &apos;&lt;br&gt;&apos;);&#125;//再次调用Student.sayHello();//查看Student的属性（只有 no 、 dept 和 重载了的sayHello）document.write(&apos;&lt;p&gt;&apos; + Object.keys(Student) + &apos;&lt;br&gt;&apos;); 通用上面这个示例，我们可以看到，Person里的属性并没有被真正复制到了Student中来，但是我们可以去存取。这是因为Javascript用委托实现了这一机制。其实，这就是Prototype，Person是Student的Prototype。当我们的代码需要一个属性的时候，Javascript的引擎会先看当前的这个对象中是否有这个属性，如果没有的话，就会查找他的Prototype对象是否有这个属性，一直继续下去，直到找到或是直到没有Prototype对象。为了证明这个事，我们可以使用Object.getPrototypeOf()来检验一下： 12345Student.name = &apos;aaa&apos;;//输出 aaadocument.write(&apos;&lt;p&gt;&apos; + Student.name + &apos;&lt;/p&gt;&apos;);//输出 Chen Haodocument.write(&apos;&lt;p&gt;&apos; +Object.getPrototypeOf(Student).name + &apos;&lt;/p&gt;&apos;); 于是，你还可以在子对象的函数里调用父对象的函数，就好像C++里的 Base::func() 一样。于是，我们重载hello的方法就可以使用父类的代码了，如下所示： 1234567//新版的重载SayHello方法Student.sayHello = function (person) &#123; Object.getPrototypeOf(this).sayHello.call(this); var hello = &quot;my student no is: &quot; + this. no + &quot;， &lt;br&gt;&quot; + &quot;my departent is: &quot; + this. dept; document.write(hello + &apos;&lt;br&gt;&apos;);&#125; 这个很强大吧。 组合上面的那个东西还不能满足我们的要求，我们可能希望这些对象能真正的组合起来。为什么要组合？因为我们都知道是这是OO设计的最重要的东西。不过，这对于Javascript来并没有支持得特别好，不好我们依然可以搞定个事。首先，我们需要定义一个Composition的函数：（target是作用于是对象，source是源对象），下面这个代码还是很简单的，就是把source里的属性一个一个拿出来然后定义到target中。 123456789101112function Composition(target, source)&#123; var desc = Object.getOwnPropertyDescriptor; var prop = Object.getOwnPropertyNames; var def_prop = Object.defineProperty; prop(source).forEach( function(key) &#123; def_prop(target, key， desc(source, key)) &#125; ) return target;&#125; 有了这个函数以后，我们就可以这来玩了： 123456789101112131415161718192021222324//艺术家var Artist = Object.create(null);Artist.sing = function() &#123; return this.name + &apos; starts singing...&apos;;&#125;Artist.paint = function() &#123; return this.name + &apos; starts painting...&apos;;&#125;//运动员var Sporter = Object.create(null);Sporter.run = function() &#123; return this.name + &apos; starts running...&apos;;&#125;Sporter.swim = function() &#123; return this.name + &apos; starts swimming...&apos;;&#125;Composition(Person, Artist);document.write(Person.sing() + &apos;&lt;br&gt;&apos;);document.write(Person.paint() + &apos;&lt;br&gt;&apos;);Composition(Person, Sporter);document.write(Person.run() + &apos;&lt;br&gt;&apos;);document.write(Person.swim() + &apos;&lt;br&gt;&apos;);//看看 Person中有什么？（输出：sayHello,sing,paint,swim,run）document.write(&apos;&lt;p&gt;&apos; + Object.keys(Person) + &apos;&lt;br&gt;&apos;); Prototype 和 继承我们先来说说Prototype。我们先看下面的例程，这个例程不需要解释吧，很像C语言里的函数指针，在C语言里这样的东西见得多了。 1234567891011121314151617var plus = function(x，y)&#123; document.write( x + &apos; + &apos; + y + &apos; = &apos; + (x+y) + &apos;&lt;br&gt;&apos;); return x + y;&#125;;var minus = function(x，y)&#123; document.write(x + &apos; - &apos; + y + &apos; = &apos; + (x-y) + &apos;&lt;br&gt;&apos;); return x - y;&#125;;var operations = &#123; &apos;+&apos;: plus, &apos;-&apos;: minus&#125;;var calculate = function(x， y， operation)&#123; return operations[operation](x， y);&#125;;calculate(12, 4, &apos;+&apos;);calculate(24, 3, &apos;-&apos;); 那么，我们能不能把这些东西封装起来呢，我们需要使用prototype。看下面的示例： 1234567891011121314var Cal = function(x， y)&#123; this.x = x; this.y = y;&#125;Cal.prototype.operations = &#123; &apos;+&apos;: function(x， y) &#123; return x+y;&#125;, &apos;-&apos;: function(x， y) &#123; return x-y;&#125;&#125;;Cal.prototype.calculate = function(operation)&#123; return this.operations[operation](this.x， this.y);&#125;;var c = new Cal(4, 5);Cal.calculate(&apos;+&apos;);Cal.calculate(&apos;-&apos;); 这就是prototype的用法，prototype 是javascript这个语言中最重要的内容。网上有太多的文章介始这个东西了。说白了，prototype就是对一对象进行扩展，其特点在于通过“复制”一个已经存在的实例来返回新的实例，而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的（当然，这里没有真正的复制，实际只是委托）。上面的这个例子中，我们扩展了实例Cal，让其有了一个operations的属性和一个calculate的方法。这样，我们可以通过这一特性来实现继承。还记得我们最最前面的那个Person吧， 下面的示例是创建一个Student来继承Person。 12345678910111213141516171819202122232425262728293031323334353637function Person(name, email, website)&#123; this.name = name; this.email = email; this.website = website;&#125;;Person.prototype.sayHello = function()&#123; var hello = &quot;Hello, I am &quot;+ this.name + &quot;， &lt;br&gt;&quot; + &quot;my email is: &quot; + this.email + &quot;， &lt;br&gt;&quot; + &quot;my website is: &quot; + this.website; return hello;&#125;;function Student(name, email, website, no, dept)&#123; var proto = Object.getPrototypeOf; proto(Student.prototype).constructor.call(this, name, email, website); this.no = no; this.dept = dept;&#125;// 继承prototypeStudent.prototype = Object.create(Person.prototype);//重置构造函数Student.prototype.constructor = Student;//重载sayHello()Student.prototype.sayHello = function()&#123; var proto = Object.getPrototypeOf; var hello = proto(Student.prototype).sayHello.call(this) + &apos;&lt;br&gt;&apos;; hello += &quot;my student no is: &quot; + this. no + &quot;， &lt;br&gt;&quot; + &quot;my departent is: &quot; + this. dept; return hello;&#125;;var me = new Student( &quot;Chen Hao&quot;, &quot;haoel@hotmail.com&quot;, &quot;http://coolshell.cn&quot;, &quot;12345678&quot;, &quot;Computer Science&quot;);document.write(me.sayHello()); 兼容性上面的这些代码并不一定能在所有的浏览器下都能运行，因为上面这些代码遵循 ECMAScript 5 的规范，关于ECMAScript 5 的浏览器兼容列表，你可以看这里“ES5浏览器兼容表”。本文中的所有代码都在Chrome最新版中测试过了。下面是一些函数，可以用在不兼容ES5的浏览器中：Object.create()函数 1234567function clone(proto) &#123; function Dummy() &#123; &#125; Dummy.prototype = proto; Dummy.prototype.constructor = Dummy; return new Dummy(); //等价于Object.create(Person);&#125;var me = clone(Person); defineProperty()函数 123456789function defineProperty(target, key， descriptor) &#123; if (descriptor.value)&#123; target[key] = descriptor.value; &#125;else &#123; descriptor.get &amp;&amp; target.__defineGetter__(key， descriptor.get); descriptor.set &amp;&amp; target.__defineSetter__(key， descriptor.set); &#125; return target&#125; keys()函数 1234567function keys(object) &#123; var result, key result = []; for (key in object)&#123; if (object.hasOwnProperty(key)) result.push(key) &#125; return result;&#125; Object.getPrototypeOf() 函数 12345function proto(object) &#123; return !object? null : &apos;__proto__&apos; in object? object.__proto__ : /* not exposed? */ object.constructor.prototype&#125; bind 函数 1234567var slice = [].slicefunction bind(fn, bound_this) &#123; var bound_args bound_args = slice.call(arguments, 2) return function() &#123; var args args = bound_args.concat(slice.call(arguments)) return fn.apply(bound_this, args) &#125;&#125;","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"jquery留着以后用","date":"2015-11-01T16:00:00.000Z","path":"/template/20151102/jquery-nature/","text":"1. 如何创建嵌套的过滤器 //允许你减少集合中的匹配元素的过滤器， //只剩下那些与给定的选择器匹配的部分。在这种情况下， //查询删除了任何没（:not）有（:has） //包含class为“selected”（.selected）的子节点。 .filter(&quot;:not(:has(.selected))&quot;) 2. 如何重用元素搜索 var allItems = $(&quot;div.item&quot;); var keepList = $(&quot;div#container1 div.item&quot;); //现在你可以继续使用这些jQuery对象来工作了。例如， //基于复选框裁剪“keep list”，复选框的名称 //符合 &lt;DIV&gt;class names: $(formToLookAt + &quot; input:checked&quot;).each(function () { keepList = keepList.filter(&quot;.&quot; + $(this).attr(&quot;name&quot;)); }); &lt;/DIV&gt; 3. 任何使用has()来检查某个元素是否包含某个类或是元素 //jQuery 1.4.*包含了对这一has方法的支持。该方法找出 //某个元素是否包含了其他另一个元素类或是其他任何的 //你正在查找并要在其之上进行操作的东东。 $(&quot;input&quot;).has(&quot;.email&quot;).addClass(&quot;email_icon&quot;); 4. 如何使用jQuery来切换样式表 //找出你希望切换的媒体类型（media-type），然后把href设置成新的样式表。 $('link[media=&quot;screen&quot;]').attr('href','Alternative.css'); 5. 如何限制选择范围（基于优化目的） //尽可能使用标签名来作为类名的前缀， //这样jQuery就不需要花费更多的时间来搜索 //你想要的元素。还要记住的一点是， //针对于你的页面上的元素的操作越具体化， //就越能降低执行和搜索的时间。 var in_stock = $('#shopping_cart_items input.is_in_stock'); &lt;ul id=&quot;shopping_cart_items&quot;&gt; &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;Item-X&quot; name=&quot;item&quot; class=&quot;is_in_stock&quot; /&gt;Item X&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;Item-Y&quot; name=&quot;item&quot; class=&quot;3-5_days&quot; /&gt;Item Y&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;radio&quot; value=&quot;Item-Z&quot; name=&quot;item&quot; class=&quot;unknown&quot; /&gt;Item Z&lt;/li&gt; &lt;/ul&gt; 6. 如何正确地使用ToggleClass //切换（toggle）类允许你根据某个类的 //是否存在来添加或是删除该类。 //这种情况下有些开发者使用： a.hasClass('blueButton') ? a.removeClass('blueButton') : a.addClass('blueButton'); //toggleClass允许你使用下面的语句来很容易地做到这一点 a.toggleClass('blueButton'); 7. 如何设置IE特有的功能 if($.browser.msie) {// Internet Explorer其实不那么好用 } 8. 如何使用jQuery来代替一个元素 $('#thatdiv').replaceWith('fnuh'); 9. 如何验证某个元素是否为空 if($('#keks').html().trim()) {//什么都没有找到; } 10. 如何从一个未排序的集合中找出某个元素的索引号 $(&quot;ul &gt; li&quot;).click(function () { var index = $(this).prevAll().length; }); 11. 如何把函数绑定到事件上 $('#foo').bind('click', function () { alert('User clicked on &quot;foo.&quot;'); }); 12. 如何追加或是添加html到元素中 $('#lal').append('sometext'); 13. 在创建元素时，如何使用对象字面量（literal）来定义属性 vare = $(&quot;&quot;, { href:&quot;#&quot;,class:&quot;a-class another-class&quot;, title:&quot;...&quot;}); 14. 如何使用多个属性来进行过滤 //在使用许多相类似的有着不同类型的input元素时， //这种基于精确度的方法很有用 var elements = $('#someid input[type=sometype][value=somevalue]').get(); 15. 如何使用jQuery来预加载图像 jQuery.preloadImages = function () { for (var i = 0; i &lt; arguments.length; i++) { $(&quot;&lt;img /&gt;&quot;).attr('src', arguments[i]); } }; //用法$.preloadImages('image1.gif','/path/to/image2.png','some/image3.jpg'); 16. 如何为任何与选择器相匹配的元素设置事件处理程序 $('button.someClass').live('click', someFunction); //注意，在jQuery 1.4.2中，delegate和undelegate选项 //被引入代替live，因为它们提供了更好的上下文支持 //例如，就table来说，以前你会用 //.live() $(&quot;table&quot;).each(function () { $(&quot;td&quot;, this).live(&quot;hover&quot;, function () { $(this).toggleClass(&quot;hover&quot;); }); }); //现在用 $(&quot;table&quot;).delegate(&quot;td&quot;, &quot;hover&quot;, function () { $(this).toggleClass(&quot;hover&quot;); }); 17. 如何找到一个已经被选中的option元素 $('#someElement').find('option:selected'); 18. 如何隐藏一个包含了某个值文本的元素 $(&quot;p.value:contains('thetextvalue')&quot;).hide(); 19. 如果自动滚动到页面中的某区域 jQuery.fn.autoscroll =function(selector) { $('html,body').animate( { scrollTop: $(this).offset().top }, 500 ); } //然后像这样来滚动到你希望去到的class/area上。 $('.area_name').autoscroll(); 20. 如何检测各种浏览器 if( $.browser.safari)//检测Safari if($.browser.msie &amp;&amp; $.browser.version &gt; 6 )//检测IE6及之后版本 if($.browser.msie &amp;&amp; $.browser.version &lt;= 6 )//检测IE6及之前版本 if($.browser.mozilla &amp;&amp; $.browser.version &gt;='1.8')//检测FireFox 2及之后版本 21. 如何替换串中的词 varel = $('#id' ); el.html(el.html().replace(/word/ig,'')); 22. 如何禁用右键单击上下文菜单 $(document).bind('contextmenu',function(e) { return false;}); 23. 如何定义一个定制的选择器 $.expr[':'].mycustomselector = function(element, index, meta, stack){ // element- 一个DOM元素 // index – 栈中的当前循环索引 // meta – 有关选择器的元数据 // stack – 要循环的所有元素的栈 // 如果包含了当前元素就返回true // 如果不包含当前元素就返回false }; // 定制选择器的用法： $('.someClasses:test').doSomething(); 24. 如何检查某个元素是否存在 if($('#someDiv').length) {//你妹，终于找到了 } 25. 如何使用jQuery来检测右键和左键的鼠标单击两种情况 $(&quot;#someelement&quot;).live('click', function (e) { if ((!$.browser.msie &amp;&amp; e.button == 0) || ($.browser.msie &amp;&amp; e.button == 1)) { alert(&quot;Left Mouse Button Clicked&quot;); } else if (e.button == 2) { alert(&quot;Right Mouse Button Clicked&quot;); } }); 26. 如何显示或是删除input域中的默认值 //这段代码展示了在用户未输入值时， //如何在文本类型的input域中保留 //一个默认值 $(&quot;.swap&quot;).each(function (i) { wap_val[i] = $(this).val(); $(this).focusin(function () { if ($(this).val() == swap_val[i]) { $(this).val(&quot;&quot;); } }).focusout(function () { if ($.trim($(this).val()) == &quot;&quot;) { $(this).val(swap_val[i]); } }); }); 27. 如何在一段时间之后自动隐藏或关闭元素（支持1.4版本） //这是1.3.2中我们使用setTimeout来实现的方式 setTimeout(function () { $('.mydiv').hide('blind', {}, 500) }, 5000); //而这是在1.4中可以使用delay()这一功能来实现的方式（这很像是休眠） $(&quot;.mydiv&quot;).delay(5000).hide('blind', {}, 500); 28. 如何把已创建的元素动态地添加到DOM中 varnewDiv = $(''); newDiv.attr('id','myNewDiv').appendTo('body'); 29. 如何限制“Text-Area”域中的字符的个数 jQuery.fn.maxLength = function (max) { this.each(function () { var type = this.tagName.toLowerCase(); var inputType = this.type ? this.type.toLowerCase() : null; if (type == &quot;input&quot; &amp;&amp; inputType == &quot;text&quot; || inputType == &quot;password&quot;) { this.maxLength = max; } else if (type == &quot;textarea&quot;) { this.onkeypress = function (e) { var ob = e || event; var keyCode = ob.keyCode; var hasSelection = document.selection ? document.selection.createRange().text.length &gt; 0 : this.selectionStart != this.selectionEnd; return !(this.value.length &gt;= max &amp;&amp; (keyCode &gt; 50 || keyCode == 32 || keyCode == 0 || keyCode == 13) &amp;&amp; !ob.ctrlKey &amp;&amp; !ob.altKey &amp;&amp; !hasSelection); }; this.onkeyup = function () { if (this.value.length &gt; max) { this.value = this.value.substring(0, max); } }; } }); }; //用法$('#mytextarea').maxLength(500); 30. 如何为函数创建一个基本的测试 //把测试单独放在模块中 module(&quot;Module B&quot;); test(&quot;some other test&quot;, function () { //指明测试内部预期有多少要运行的断言 expect(2); //一个比较断言，相当于JUnit的assertEquals equals(true, false, &quot;failing test&quot;); equals(true, true, &quot;passing test&quot;); }); 31. 如何在jQuery中克隆一个元素 varcloned = $('#somediv').clone(); 32. 在jQuery中如何测试某个元素是否可见 if($(element).is(':visible')) {//该元素是可见的 } 33. 如何把一个元素放在屏幕的中心位置 jQuery.fn.center = function () { this.css('position', 'absolute'); this.css('top', ($(window).height() - this.height()) / +$(window).scrollTop() + 'px'); this.css('left', ($(window).width() - this.width()) / 2 + $(window).scrollLeft() + 'px'); return this; } //这样来使用上面的函数：$(element).center(); 34. 如何把有着某个特定名称的所有元素的值都放到一个数组中 vararrInputValues =newArray(); $(&quot;input[name='table[]']&quot;).each(function() { arrInputValues.push($(this).val()); }); 35. 如何从元素中除去HTML (function ($) { $.fn.stripHtml = function () { var regexp = /&lt;(&quot;[^&quot;]*&quot;|'[^']*'|[^'&quot;&gt;])*&gt;/gi; this.each(function () { $(this).html($(this).html().replace(regexp, &quot;&quot;)); }); return $(this); } })(jQuery); //用法：$('p').stripHtml(); 36. 如何使用closest来取得父元素 $('#searchBox').closest('div'); 37. 如何使用Firebug和Firefox来记录jQuery事件日志 // 允许链式日志记录 // 用法： $('#someDiv').hide().log('div hidden').addClass('someClass'); jQuery.log = jQuery.fn.log = function (msg) { if (console) { console.log(&quot;%s: %o&quot;, msg, this); } return this; }; 38. 如何强制在弹出窗口中打开链接 jQuery('a.popup').live('click', function () { newwindow = window.open($(this).attr('href'), '', 'height=200,width=150'); if (window.focus) { newwindow.focus(); } return false; }); 39. 如何强制在新的选项卡中打开链接 jQuery('a.newTab').live('click', function () { newwindow = window.open($(this).href); jQuery(this).target = &quot;_blank&quot;; return false; }); 40. 在jQuery中如何使用.siblings()来选择同辈元素 // 不这样做 $('#nav li').click(function () { $('#nav li').removeClass('active'); $(this).addClass('active'); }); //替代做法是 $('#nav li').click(function () { $(this).addClass('active').siblings().removeClass('active'); }); 41. 如何切换页面上的所有复选框 vartog =false;// 或者为true，如果它们在加载时为被选中状态的话 $('a').click(function () { $(&quot;input[type=checkbox]&quot;).attr(&quot;checked&quot;, !tog); tog = !tog; }); 42. 如何基于一些输入文本来过滤一个元素列表 //如果元素的值和输入的文本相匹配的话 //该元素将被返回 $('.someClass').filter(function () { return $(this).attr('value') == $('input#someId').val(); }) 43. 如何获得鼠标垫光标位置x和y $(document).ready(function () { $(document).mousemove(function (e) { $('#XY').html(&quot;X Axis : &quot; + e.pageX + &quot; | Y Axis &quot; + e.pageY); }); }); 44. 如何把整个的列表元素（List Element，LI）变成可点击的 $(&quot;ul li&quot;).click(function () { window.location = $(this).find(&quot;a&quot;).attr(&quot;href&quot;); return false; }); &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link 3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link 4&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 45. 如何使用jQuery来解析XML（基本的例子） function parseXml(xml) { //找到每个Tutorial并打印出author $(xml).find(&quot;Tutorial&quot;).each(function () { $(&quot;#output&quot;).append($(this).attr(&quot;author&quot;) + &quot;&quot;); }); } 46. 如何检查图像是否已经被完全加载进来 $('#theImage').attr('src', 'image.jpg').load(function () { alert('This Image Has Been Loaded'); }); 47. 如何使用jQuery来为事件指定命名空间 //事件可以这样绑定命名空间 $('input').bind('blur.validation', function (e) { // ... }); //data方法也接受命名空间 $('input').data('validation.isValid', true); 48. 如何检查cookie是否启用 var dt = new Date(); dt.setSeconds(dt.getSeconds() + 60); document.cookie = &quot;cookietest=1; expires=&quot; + dt.toGMTString(); var cookiesEnabled = document.cookie.indexOf(&quot;cookietest=&quot;) != -1; if (!cookiesEnabled) { //没有启用cookie } 49. 如何让cookie过期 var date = new Date(); date.setTime(date.getTime() + (x * 60 * 1000)); $.cookie('example', 'foo', { expires: date }); 50. 如何使用一个可点击的链接来替换页面中任何的URL $.fn.replaceUrl = function () { var regexp = /((ftp|http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&amp;%@!\\-\\/]))?)/gi; this.each(function () { $(this).html( $(this).html().replace(regexp, '&lt;a href=&quot;$1&quot;&gt;$1&lt;/a&gt;') ); }); return $(this); } //用法 $('p').replaceUrl();","tags":[{"name":"jquery","slug":"jquery","permalink":"http://yoursite.com/tags/jquery/"}]}]